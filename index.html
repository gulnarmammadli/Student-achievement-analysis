<!doctype html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Learning Styles & Class Analysis</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.0/dist/simple-statistics.min.js"></script>

    <style>
      html,
      body {
        height: 100%;
      }
      body {
        background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
      }
      .card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 6px 30px rgba(20, 20, 60, 0.06);
        padding: 18px;
      }
      .muted {
        color: #6b7280;
        font-size: 13px;
      }
      .tiny {
        font-size: 12px;
        color: #94a3b8;
      }
      .scroll-y {
        max-height: 420px;
        overflow: auto;
      }
      .chart-holder {
        height: 320px;
      }
      @media (max-width: 900px) {
        .chart-holder {
          height: 220px;
        }
      }
    </style>
  </head>
  <body class="p-6">
    <div class="max-w-[1200px] mx-auto">
      <!-- Header -->
      <header class="flex items-center justify-between mb-6">
        <div>
          <h1 class="text-2xl font-semibold">
            Learning Styles & Class Analysis
          </h1>
          <div class="muted">
            Load questions from Excel, let students take the test, see instant
            analyses and charts.
          </div>
        </div>

        <div class="flex items-center gap-3">
          <label class="flex items-center gap-2 card px-3 py-2">
            <input
              id="xlsInput"
              type="file"
              accept=".xlsx,.xls"
              class="hidden"
            />
            <button
              id="btnLoadXLS"
              class="bg-indigo-600 text-white px-3 py-2 rounded"
            >
              Load Questions (.xlsx)
            </button>
            <span id="xlsInfo" class="tiny ml-2"
              >No question file loaded yet</span
            >
          </label>

          <button
            id="btnAdmin"
            class="bg-slate-800 text-white px-3 py-2 rounded"
          >
            Admin
          </button>
        </div>
      </header>

      <!-- Main layout -->
      <main class="grid grid-cols-12 gap-6">
        <!-- Left area: Student form / questions -->
        <section class="col-span-12 lg:col-span-6 space-y-4">
          <div id="studentCard" class="card">
            <h2 class="text-lg font-medium">Student Information & Test</h2>
            <p class="muted">
              Enter name and optional GPA, then start the test.
            </p>

            <div class="grid grid-cols-2 gap-3 mt-3">
              <input
                id="studentName"
                placeholder="Student Name"
                class="border rounded px-3 py-2"
              />
              <input
                id="studentGPA"
                placeholder="GPA (optional, 0‚Äì100)"
                type="number"
                step="0.1"
                min="0"
                max="100"
                class="border rounded px-3 py-2"
              />
              <select id="studentGender" class="border rounded px-3 py-2">
                <option value="">Select gender</option>
                <option>Female</option>
                <option>Male</option>
                <option>Other</option>
              </select>
              <select id="courseType" class="border rounded px-3 py-2">
                <option value="">Course delivery type</option>
                <option>Online</option>
                <option>Hybrid</option>
                <option>Face-to-face</option>
              </select>
              <input
                id="weeklyHours"
                placeholder="Weekly study hours (approx.)"
                type="number"
                class="border rounded px-3 py-2"
              />
              <select id="learningResource" class="border rounded px-3 py-2">
                <option value="">Preferred learning resource</option>
                <option>Video</option>
                <option>Text</option>
                <option>Practical</option>
              </select>
            </div>

            <div class="mt-4 flex gap-3">
              <button
                id="startTest"
                class="bg-emerald-600 text-white px-4 py-2 rounded"
              >
                Start Test
              </button>
              <button
                id="saveStudent"
                class="bg-indigo-600 text-white px-4 py-2 rounded"
              >
                Save (after answering)
              </button>
              <button
                id="clearResponses"
                class="bg-red-500 text-white px-4 py-2 rounded"
              >
                Clear Answers
              </button>
            </div>
          </div>

          <div id="questionsCard" class="card">
            <h3 class="text-lg font-medium">Questions</h3>
            <p class="muted">
              Once you load the Excel file, questions will be listed here. Each
              item is treated as a single-answer question.
            </p>
            <div
              id="questionsContainer"
              class="scroll-y mt-3 space-y-4 p-2"
            ></div>
          </div>
        </section>

        <!-- Right area: Controls + Charts + Students -->
        <section class="col-span-12 lg:col-span-6 space-y-4">
          <div class="card">
            <h3 class="text-lg font-medium">Quick Actions</h3>
            <div class="grid grid-cols-2 gap-3 mt-3">
              <button
                id="exportAll"
                class="bg-green-600 text-white px-3 py-2 rounded"
              >
                Download Report (JSON)
              </button>
              <button
                id="runTests"
                class="bg-violet-600 text-white px-3 py-2 rounded"
              >
                Run Statistical Tests
              </button>

              <button
                id="exportCSV"
                class="bg-sky-600 text-white px-3 py-2 rounded"
              >
                Download CSV
              </button>

              <label
                class="bg-red-600 text-white px-3 py-2 rounded flex items-center justify-center cursor-pointer"
              >
                <input type="file" id="importJSON" class="hidden" />
                Upload JSON file
              </label>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mt-4">
              <div class="card p-3">
                <h4 class="font-medium">Class Quick Summary</h4>
                <div id="quickSummary" class="muted mt-2">No data yet.</div>
              </div>

              <div class="card p-3">
                <h4 class="font-medium">Instructional Suggestion</h4>
                <div id="autoSuggestion" class="muted mt-2">‚Äî</div>
              </div>
            </div>
          </div>

          <div class="card">
            <h3 class="text-lg font-medium">Charts</h3>
            <div class="grid grid-cols-1 gap-3 mt-3">
              <div class="chart-holder card p-3 row-span-1">
                <canvas id="varkBar"></canvas>
              </div>
              <div class="chart-holder card p-3 row-span-1">
                <canvas id="kolbBar"></canvas>
              </div>
            </div>
          </div>

          <div class="card">
            <h3 class="text-lg font-medium">Student List</h3>
            <div id="studentsTable" class="mt-2 scroll-y"></div>
          </div>
        </section>
      </main>

      <!-- Admin modal -->
      <div
        id="adminModal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50"
      >
        <div class="bg-white rounded-lg w-[90%] md:w-3/5 p-4 shadow-xl">
          <div class="flex justify-between items-center mb-3">
            <h3 class="text-lg font-semibold">üîí Admin Login</h3>
            <button id="closeAdmin" class="text-slate-600">Close ‚úñ</button>
          </div>
          <div>
            <input
              id="adminPassword"
              placeholder="Password (default: 12345)"
              type="password"
              class="border rounded px-3 py-2 w-full"
            />
            <div class="mt-3 flex justify-end gap-3">
              <button
                id="adminLoginBtn"
                class="bg-indigo-600 text-white px-4 py-2 rounded"
              >
                Log in
              </button>
              <button id="adminCancel" class="bg-gray-300 px-4 py-2 rounded">
                Cancel
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Admin panel (overlay) -->
      <div
        id="adminPanel"
        class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 overflow-auto"
      >
        <div
          class="max-w-[1250px] w-[95%] mx-auto mt-8 bg-white rounded-lg p-6 mb-8 shadow-lg"
        >
          <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-semibold">Admin Panel ‚Äî Class Analyses</h2>
            <div class="flex gap-2">
              <button
                id="clearStorageBtn"
                class="bg-red-600 text-white px-3 py-2 rounded"
              >
                Clear Storage
              </button>
              <button
                id="adminExport"
                class="bg-green-600 text-white px-3 py-2 rounded"
              >
                JSON ƒ∞ndir
              </button>
              <button id="adminClose" class="bg-gray-300 px-3 py-2 rounded">
                Close
              </button>
            </div>
          </div>

          <nav class="flex gap-2 mb-4">
            <button
              class="tabBtn bg-slate-100 px-3 py-2 rounded"
              data-tab="tab-list"
            >
              Class List
            </button>
            <button
              class="tabBtn bg-slate-100 px-3 py-2 rounded"
              data-tab="tab-vark"
            >
              VARK Analysis
            </button>
            <button
              class="tabBtn bg-slate-100 px-3 py-2 rounded"
              data-tab="tab-kolb"
            >
              KOLB Analysis
            </button>

            <button
              class="tabBtn bg-slate-100 px-3 py-2 rounded"
              data-tab="tab-stats"
            >
              All Statistics
            </button>
          </nav>

          <section id="tab-list" class="tabContent">
            <h3 class="font-medium">Student List</h3>
            <div id="adminStudents" class="mt-3"></div>
          </section>

          <section id="tab-vark" class="hidden tabContent">
            <h3 class="font-medium">VARK Details</h3>
            <div
              id="adminVark"
              class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3"
            ></div>
          </section>

          <section id="tab-kolb" class="hidden tabContent">
            <h3 class="font-medium">KOLB Details</h3>
            <div
              id="adminKolb"
              class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3"
            ></div>
          </section>

          <section id="tab-stats" class="hidden tabContent">
            <h3 class="font-medium">Statistical Tests & Summaries</h3>
            <pre
              id="statOutput"
              class="mt-3 bg-slate-50 p-4 rounded text-sm border border-slate-200 whitespace-pre-wrap break-words"
            ></pre>
          </section>
        </div>
      </div>
    </div>

    <script>
      // Shared state for questions, saved students and charts
      let rawQuestions = [];
      let students = [];
      let charts = {};

      // Small helper utilities
      const uid = () => Math.random().toString(36).slice(2, 9);
      const show = (id) =>
        document.getElementById(id).classList.remove("hidden");
      const hide = (id) => document.getElementById(id).classList.add("hidden");

      // Load any existing data from localStorage when the page opens
      function loadFromStorage() {
        students = JSON.parse(localStorage.getItem("students_v1") || "[]");
        renderStudentsTable();
        renderAllCharts();
        computeQuickSummary();
      }
      loadFromStorage();

      // Read questions from the uploaded Excel file
      document
        .getElementById("btnLoadXLS")
        .addEventListener("click", () =>
          document.getElementById("xlsInput").click(),
        );
      document
        .getElementById("xlsInput")
        .addEventListener("change", async (ev) => {
          const f = ev.target.files[0];
          if (!f) return;
          document.getElementById("xlsInfo").innerText = "Loading...";
          const data = await f.arrayBuffer();
          const wb = XLSX.read(data);
          const sheetName = wb.SheetNames[0];
          const sheet = wb.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(sheet, { defval: "" });

          rawQuestions = json.map((r, idx) => {
            const qText =
              r.question ||
              r.soru ||
              r.Question ||
              Object.values(r)[0] ||
              "Question " + (idx + 1);
            const opts = [];
            ["A", "optionA", "a", "secenek1", "Option1", "opt1"].forEach(
              (k) => {
                if (r[k]) opts.push(r[k]);
              },
            );
            ["B", "optionB", "b", "secenek2", "Option2", "opt2"].forEach(
              (k) => {
                if (r[k]) opts.push(r[k]);
              },
            );
            ["C", "optionC", "c", "secenek3", "Option3", "opt3"].forEach(
              (k) => {
                if (r[k]) opts.push(r[k]);
              },
            );
            ["D", "optionD", "d", "secenek4", "Option4", "opt4"].forEach(
              (k) => {
                if (r[k]) opts.push(r[k]);
              },
            );
            if (opts.length === 0) {
              const vals = Object.values(r)
                .slice(1)
                .filter((v) => v !== "");
              for (let i = 0; i < Math.min(4, vals.length); i++)
                opts.push(vals[i]);
            }
            const cat = (
              r.category ||
              r.kategori ||
              r.Category ||
              r.Kategori ||
              ""
            )
              .toString()
              .trim();
            return {
              id: uid(),
              q: qText,
              options: opts.length ? opts : ["A", "B", "C", "D"],
              category: cat || null,
              index: idx,
            };
          });

          const anyCat = rawQuestions.some((q) => q.category);
          if (!anyCat) {
            for (let i = 0; i < rawQuestions.length; i++) {
              if (i < 16) rawQuestions[i].category = "VARK";
              else if (i < 28) rawQuestions[i].category = "Kolb";
            }
          }

          document.getElementById("xlsInfo").innerText =
            `${rawQuestions.length} questions loaded`;
          renderQuestions();
        });

      // Show questions and options on the page
      function renderQuestions() {
        const container = document.getElementById("questionsContainer");
        container.innerHTML = "";
        if (!rawQuestions.length) {
          container.innerHTML =
            '<div class="muted">No questions yet. Please load an Excel file.</div>';
          return;
        }
        rawQuestions.forEach((q, idx) => {
          const div = document.createElement("div");
          div.className = "border rounded p-3";
          let optsHtml = "";
          q.options.forEach((opt, oi) => {
            const id = `q-${q.id}-o-${oi}`;
            optsHtml += `<label class="flex items-center gap-2"><input type="radio" name="q-${q.id}" value="${oi}" id="${id}" /> <span class="text-sm">${opt}</span></label>`;
          });
          div.innerHTML = `<div class="flex items-start justify-between"><div><div class="text-sm font-medium">#${
            idx + 1
          } <span class="muted">[${
            q.category || "Unknown"
          }]</span></div><div class="mt-1">${
            q.q
          }</div></div></div><div class="mt-3 space-y-2">${optsHtml}</div>`;
          container.appendChild(div);
        });
      }

      // Basic controls around the test section
      document.getElementById("startTest").addEventListener("click", () => {
        if (!rawQuestions.length) {
          alert("Please load the questions first.");
          return;
        }
        document
          .getElementById("questionsContainer")
          .scrollIntoView({ behavior: "smooth" });
      });

      document
        .getElementById("clearResponses")
        .addEventListener("click", () => {
          rawQuestions.forEach((q) => {
            const radios = document.getElementsByName("q-" + q.id);
            radios.forEach((r) => (r.checked = false));
          });
        });

      // Decide which Kolb learning type is dominant
      function calculateKolbType(CE, RO, AC, AE) {
        const ac_ce = AC - CE;
        const ae_ro = AE - RO;

        if (ac_ce > 0 && ae_ro > 0) {
          return "Converger";
        } else if (ac_ce > 0 && ae_ro <= 0) {
          return "Assimilator";
        } else if (ac_ce <= 0 && ae_ro > 0) {
          return "Accommodator";
        } else if (ac_ce <= 0 && ae_ro <= 0) {
          return "Diverger";
        }

        return "Diverger";
      }

      // Read answers, calculate scores and store the student
      document
        .getElementById("saveStudent")
        .addEventListener("click", () => saveStudent());

      function saveStudent() {
        const name = document.getElementById("studentName").value.trim();
        if (!name) {
          alert("Student name is required.");
          return;
        }

        const meta = {
          name,
          gpa: Number(document.getElementById("studentGPA").value) || null,
          gender: document.getElementById("studentGender").value || null,
          courseType: document.getElementById("courseType").value || null,
          weeklyHours:
            Number(document.getElementById("weeklyHours").value) || null,
          learningResource:
            document.getElementById("learningResource").value || null,
          savedAt: new Date().toISOString(),
        };

        const responses = {};
        rawQuestions.forEach((q) => {
          const radios = document.getElementsByName("q-" + q.id);
          let val = null;
          radios.forEach((r) => {
            if (r.checked) val = Number(r.value);
          });
          responses[q.index] = val;
        });

        const scores = {
          VARK: { V: 0, A: 0, R: 0, K: 0 },
          Kolb: { CE: 0, RO: 0, AC: 0, AE: 0 },
        };

        rawQuestions.forEach((q, i) => {
          const resp = responses[q.index];
          if (resp === null || resp === undefined) return;
          const cat = (q.category || "").toLowerCase();
          if (cat.includes("vark")) {
            const map = ["V", "A", "R", "K"];
            const key = map[resp] || map[resp % 4];
            scores.VARK[key] += 1;
          } else if (cat.includes("kolb")) {
            const map = ["CE", "RO", "AC", "AE"];
            const key = map[resp] || map[resp % 4];
            scores.Kolb[key] += 1;
          }
        });

        const entries = Object.entries(scores.VARK).sort((a, b) => b[1] - a[1]);
        const varkDom =
          entries.filter((e) => e[1] === entries[0][1]).length > 1
            ? "Multimodal"
            : entries[0][0];

        const { CE, RO, AC, AE } = scores.Kolb;
        const kolbType = calculateKolbType(CE, RO, AC, AE);

        const student = {
          id: uid(),
          meta,
          responses,
          scores,
          dominant: { vark: varkDom, kolb: kolbType },
        };

        students.push(student);
        localStorage.setItem("students_v1", JSON.stringify(students));
        renderStudentsTable();
        computeQuickSummary();
        renderAllCharts();

        alert("Student saved: " + meta.name);
        document.getElementById("studentName").value = "";
        document.getElementById("studentGPA").value = "";
        document.getElementById("clearResponses").click();
      }

      // Render students table
      function renderStudentsTable() {
        const el = document.getElementById("studentsTable");
        if (!students.length) {
          el.innerHTML = '<div class="muted">No students yet.</div>';
          return;
        }
        let html =
          '<table class="min-w-full text-sm"><thead class="text-left text-xs text-slate-500"><tr><th>Name</th><th>GPA</th><th>VARK</th><th>KOLB</th><th>Saved at</th></tr></thead><tbody>';
        students.forEach((s) => {
          html += `<tr class="border-t"><td class="py-2">${
            s.meta.name
          }</td><td>${
            s.meta.gpa === null ? "-" : s.meta.gpa.toFixed(2)
          }</td><td>${s.dominant.vark || "-"}</td><td>${
            s.dominant.kolb || "-"
          }</td><td class="tiny">${new Date(
            s.meta.savedAt,
          ).toLocaleString()}</td></tr>`;
        });
        html += "</tbody></table>";
        el.innerHTML = html;
      }

      // Short overview for the class panel
      function computeQuickSummary(showAlert = false) {
        if (!students.length) {
          document.getElementById("quickSummary").innerText =
            "No students yet.";
          document.getElementById("autoSuggestion").innerText =
            "There are no students in the dataset yet.";
          return;
        }
        const gpas = students.map((s) =>
          s.meta.gpa === null || s.meta.gpa === undefined ? NaN : s.meta.gpa,
        );
        const present = gpas.filter((v) => !isNaN(v));
        const count = students.length;
        const missingGPA = gpas.filter((v) => isNaN(v)).length;
        const meanGPA = present.length ? ss.mean(present) : null;
        const medianGPA = present.length ? ss.median(present) : null;
        const stdGPA = present.length ? ss.standardDeviation(present) : null;

        const vTotals = { V: 0, A: 0, R: 0, K: 0 };
        const kolbTypeCounts = {
          Diverger: 0,
          Assimilator: 0,
          Converger: 0,
          Accommodator: 0,
        };

        students.forEach((s) => {
          const sv = s.scores.VARK;
          if (sv)
            Object.keys(vTotals).forEach((k) => (vTotals[k] += sv[k] || 0));
          if (s.dominant.kolb) {
            kolbTypeCounts[s.dominant.kolb]++;
          }
        });

        const quick = `Total students: ${count}
      Missing GPA: ${missingGPA}
      Mean GPA: ${meanGPA ? meanGPA.toFixed(2) : "-"}
      Median GPA: ${medianGPA ? medianGPA.toFixed(2) : "-"}
      Std GPA: ${stdGPA ? stdGPA.toFixed(2) : "-"}
      VARK totals: V=${vTotals.V}, A=${vTotals.A}, R=${vTotals.R}, K=${vTotals.K}
      KOLB types: Div=${kolbTypeCounts.Diverger}, Assim=${
        kolbTypeCounts.Assimilator
      }, Conv=${kolbTypeCounts.Converger}, Accom=${
        kolbTypeCounts.Accommodator
      }`;

        document.getElementById("quickSummary").innerText = quick;

        const totalRaw = vTotals.V + vTotals.A + vTotals.R + vTotals.K;
        const total = totalRaw === 0 ? 1 : totalRaw;
        const vShare = vTotals.V / total;
        const aShare = vTotals.A / total;
        const rShare = vTotals.R / total;
        const kShare = vTotals.K / total;

        const lowGpaGroup = students.filter(
          (s) => s.meta.gpa !== null && s.meta.gpa < 60,
        );
        const hasRisk = lowGpaGroup.length > 0;

        const THRESHOLD = 0.4;
        const above = [];

        if (vShare >= THRESHOLD) above.push("V");
        if (aShare >= THRESHOLD) above.push("A");
        if (rShare >= THRESHOLD) above.push("R");
        if (kShare >= THRESHOLD) above.push("K");

        let finalSuggestion = "";

        if (above.length === 1) {
          const style = above[0];

          const styleFullNames = {
            V: "Visual",
            A: "Aural",
            R: "Read/Write",
            K: "Kinesthetic",
          };
          const messages = {
            V: "Most students in the class seem to learn better through visual materials. Using diagrams, charts, and simple visual explanations will likely make the lessons clearer.",
            A: "Many students prefer learning by listening. Including discussions, verbal explanations, and short peer conversations may improve their understanding.",
            R: "The group shows a noticeable tendency toward reading and writing. Providing written materials, structured notes, and short writing tasks can support learning.",
            K: "A large part of the class learns best by doing. Hands-on activities, simple simulations, and practice-based tasks are expected to be more effective.",
          };

          finalSuggestion = messages[style];

          if (hasRisk) {
            finalSuggestion += ` \n\n‚ö†Ô∏è Note: Although ${styleFullNames[style]} is dominant, clustering shows some students are struggling with low GPA. Supplement your lessons with additional practical support for this group.`;
          }
        } else {
          finalSuggestion =
            "The class demonstrates a multimodal learning pattern, indicating that a combination of instructional strategies is likely to be more appropriate than a single dominant approach.";
        }

        document.getElementById("autoSuggestion").innerText = finalSuggestion;

        if (showAlert)
          alert(
            "Analysis complete! You can check the details in the Quick Summary panel.",
          );
      }

      // Small collection of helpers used for the statistical tests
      function contingencyTable(catA, catB) {
        const aVals = Array.from(new Set(catA));
        const bVals = Array.from(new Set(catB));
        const table = Array(aVals.length)
          .fill(0)
          .map(() => Array(bVals.length).fill(0));
        for (let i = 0; i < catA.length; i++) {
          const a = catA[i],
            b = catB[i];
          const ai = aVals.indexOf(a),
            bi = bVals.indexOf(b);
          table[ai][bi] += 1;
        }
        return { table, aVals, bVals };
      }

      function chiSquareTest(table) {
        const r = table.length,
          c = table[0].length;
        const rowSums = table.map((row) => row.reduce((s, x) => s + x, 0));
        const colSums = Array(c)
          .fill(0)
          .map((_, j) => table.reduce((s, row) => s + row[j], 0));
        const total = rowSums.reduce((a, b) => a + b, 0);
        let chi2 = 0;
        for (let i = 0; i < r; i++) {
          for (let j = 0; j < c; j++) {
            const expected = (rowSums[i] * colSums[j]) / total;
            const obs = table[i][j];
            if (expected > 0) chi2 += Math.pow(obs - expected, 2) / expected;
          }
        }
        const dof = (r - 1) * (c - 1);
        const p = chiSquarePValue(chi2, dof);
        return { chi2, dof, p };
      }

      function chiSquarePValue(chi2, dof) {
        if (dof <= 0) return 1;
        function gammaLn(x) {
          const cof = [
            76.18009172947146, -86.50532032941677, 24.01409824083091,
            -1.231739572450155, 0.001208650973866179, -0.000005395239384953,
          ];
          let y = x;
          let tmp = x + 5.5;
          tmp -= (x + 0.5) * Math.log(tmp);
          let ser = 1.00000000019001;
          for (let j = 0; j < 6; j++) ser += cof[j] / ++y;
          return -tmp + Math.log((2.5066282746310005 * ser) / x);
        }
        function incompletaGamma(a, x) {
          if (x < 0 || a <= 0) return 0;
          if (x === 0) return 0;
          if (x < a + 1) {
            let sum = 1 / a;
            let term = 1 / a;
            for (let n = 1; n < 100; n++) {
              term *= x / (a + n);
              sum += term;
              if (Math.abs(term) < 1e-10) break;
            }
            return sum * Math.exp(-x + a * Math.log(x) - gammaLn(a));
          } else {
            let b = x + 1 - a;
            let c = 1 / 1e-30;
            let d = 1 / b;
            let h = d;
            for (let i = 1; i < 100; i++) {
              const an = -i * (i - a);
              b += 2;
              d = an * d + b;
              if (Math.abs(d) < 1e-30) d = 1e-30;
              c = b + an / c;
              if (Math.abs(c) < 1e-30) c = 1e-30;
              d = 1 / d;
              const del = d * c;
              h *= del;
              if (Math.abs(del - 1) < 1e-10) break;
            }
            return 1 - h * Math.exp(-x + a * Math.log(x) - gammaLn(a));
          }
        }
        return 1 - incompletaGamma(dof / 2, chi2 / 2);
      }

      function oneWayANOVA(groups) {
        const validGroups = groups.filter((g) => g.length > 0);
        if (validGroups.length < 2) return null;

        const allData = validGroups.flat();
        const grandMean = ss.mean(allData);
        const n = allData.length;
        const k = validGroups.length;

        let ssBetween = 0;
        validGroups.forEach((g) => {
          const groupMean = ss.mean(g);
          ssBetween += g.length * Math.pow(groupMean - grandMean, 2);
        });

        let ssWithin = 0;
        validGroups.forEach((g) => {
          const groupMean = ss.mean(g);
          g.forEach((val) => {
            ssWithin += Math.pow(val - groupMean, 2);
          });
        });

        const dfBetween = k - 1;
        const dfWithin = n - k;
        const msBetween = ssBetween / dfBetween;
        const msWithin = ssWithin / dfWithin;
        const F = msBetween / msWithin;

        const p = fTestPValue(F, dfBetween, dfWithin);

        return {
          F,
          dfBetween,
          dfWithin,
          p,
          groupMeans: validGroups.map(ss.mean),
        };
      }

      function fTestPValue(F, df1, df2) {
        if (F <= 0 || df1 <= 0 || df2 <= 0) return 1;
        const x = df2 / (df2 + df1 * F);
        return betaIncomplete(df2 / 2, df1 / 2, x);
      }

      function betaIncomplete(a, b, x) {
        if (x <= 0) return 0;
        if (x >= 1) return 1;
        function betaLn(a, b) {
          return gammaLn(a) + gammaLn(b) - gammaLn(a + b);
        }
        function gammaLn(x) {
          const cof = [
            76.18009172947146, -86.50532032941677, 24.01409824083091,
            -1.231739572450155, 0.001208650973866179, -0.000005395239384953,
          ];
          let y = x;
          let tmp = x + 5.5;
          tmp -= (x + 0.5) * Math.log(tmp);
          let ser = 1.00000000019001;
          for (let j = 0; j < 6; j++) ser += cof[j] / ++y;
          return -tmp + Math.log((2.5066282746310005 * ser) / x);
        }
        const bt =
          Math.exp(a * Math.log(x) + b * Math.log(1 - x) - betaLn(a, b)) / a;
        if (x < (a + 1) / (a + b + 2)) {
          return (bt * betaContinuedFraction(a, b, x)) / a;
        } else {
          return 1 - (bt * betaContinuedFraction(b, a, 1 - x)) / b;
        }
      }

      function betaContinuedFraction(a, b, x) {
        const maxIterations = 100;
        const epsilon = 1e-10;
        const qab = a + b;
        const qap = a + 1;
        const qam = a - 1;
        let c = 1;
        let d = 1 - (qab * x) / qap;
        if (Math.abs(d) < 1e-30) d = 1e-30;
        d = 1 / d;
        let h = d;
        for (let m = 1; m <= maxIterations; m++) {
          const m2 = 2 * m;
          let aa = (m * (b - m) * x) / ((qam + m2) * (a + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          h *= d * c;
          aa = (-(a + m) * (qab + m) * x) / ((a + m2) * (qap + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          const del = d * c;
          h *= del;
          if (Math.abs(del - 1) < epsilon) break;
        }
        return h;
      }

      function pearson(x, y) {
        if (x.length !== y.length || x.length < 2) return null;
        return ss.sampleCorrelation(x, y);
      }

      function spearman(x, y) {
        if (x.length !== y.length || x.length < 2) return null;
        function rank(arr) {
          const sorted = arr.map((v, i) => [v, i]).sort((a, b) => a[0] - b[0]);
          const ranks = [];
          for (let i = 0; i < sorted.length; i++) ranks[sorted[i][1]] = i + 1;
          return ranks;
        }
        return pearson(rank(x), rank(y));
      }

      // Simple k-means for 2D points (used for exploratory clustering)
      function kMeans2D(points, k = 3, maxIter = 30) {
        if (!points.length || k <= 1) return null;
        if (points.length < k) k = points.length;

        const centroids = [];
        for (let i = 0; i < k; i++) {
          const idx = Math.floor((i * points.length) / k);
          centroids.push({ x: points[idx].x, y: points[idx].y });
        }

        let assignments = new Array(points.length).fill(0);

        for (let iter = 0; iter < maxIter; iter++) {
          let changed = false;

          // assignment step
          for (let i = 0; i < points.length; i++) {
            let bestIdx = -1;
            let bestDist = Infinity;
            for (let c = 0; c < k; c++) {
              const dx = points[i].x - centroids[c].x;
              const dy = points[i].y - centroids[c].y;
              const d2 = dx * dx + dy * dy;
              if (d2 < bestDist) {
                bestDist = d2;
                bestIdx = c;
              }
            }
            if (assignments[i] !== bestIdx) {
              assignments[i] = bestIdx;
              changed = true;
            }
          }

          // recompute centroids
          const sums = Array(k)
            .fill(0)
            .map(() => ({ x: 0, y: 0, count: 0 }));
          for (let i = 0; i < points.length; i++) {
            const c = assignments[i];
            sums[c].x += points[i].x;
            sums[c].y += points[i].y;
            sums[c].count++;
          }
          for (let c = 0; c < k; c++) {
            if (sums[c].count > 0) {
              centroids[c].x = sums[c].x / sums[c].count;
              centroids[c].y = sums[c].y / sums[c].count;
            }
          }

          if (!changed) break;
        }

        return { centroids, assignments, k };
      }

      //Statistical tests
      document.getElementById("runTests").addEventListener("click", () => {
        runStatTests(true);
      });

      function runStatTests(showAlert = false) {
        if (!students.length) {
          if (showAlert) {
            alert(
              "No students. Please add at least one student before running tests.",
            );
          }
          document.getElementById("statOutput").innerText =
            "No students in the dataset. Statistical tests cannot be computed.";
          return;
        }

        let output = "=== STATISTICAL TEST RESULTS ===\n\n";

        // 1. VARK MODEL ANALYSES
        output += "„Äê VARK MODEL ANALYSES „Äë\n";
        output += "‚îÄ".repeat(50) + "\n\n";

        // 1.1 Course Type √ó Dominant VARK (Chi-square)
        const courseTypes = students.map((s) => s.meta.courseType || "Unknown");
        const varkDom = students.map((s) => s.dominant.vark || "Unknown");

        const {
          table: varkTable,
          aVals: courseVals,
          bVals: varkVals,
        } = contingencyTable(courseTypes, varkDom);
        const varkChi = chiSquareTest(varkTable);

        const multimodalCount = varkDom.filter(
          (v) => v === "Multimodal",
        ).length;
        const multiPercent =
          varkDom.length > 0
            ? ((multimodalCount / varkDom.length) * 100).toFixed(1)
            : 0;

        let insightMsg = "";
        if (Number(multiPercent) > 15) {
          insightMsg =
            multiPercent +
            "% of your class is Multimodal. This suggests a strong need for varied instructional materials.";
        } else {
          insightMsg =
            "Only " +
            multiPercent +
            "% of your class is Multimodal. You can primarily focus on the dominant learning styles of the majority.";
        }

        output += `1.1 Chi-square (Course Type √ó Dominant VARK)\n`;
        output += `    œá¬≤ = ${varkChi.chi2.toFixed(4)}\n`;
        output += `    df = ${varkChi.dof}\n`;
        output += `    p-value = ${varkChi.p.toFixed(4)}\n`;
        output += `    Observation: ${
          varkChi.p < 0.05
            ? "There is a statistically significant association between course type and dominant VARK style (p < 0.05)."
            : "No statistically significant association was detected between course type and dominant VARK style (p ‚â• 0.05)."
        }\n\n`;
        output += "    Insight: " + insightMsg + "\n\n";

        // 1.2 Preferred learning resource √ó Dominant VARK (Chi-square)
        const lrForVarkA = [];
        const lrForVarkB = [];
        students.forEach((s) => {
          if (s.meta.learningResource && s.dominant.vark) {
            lrForVarkA.push(s.meta.learningResource);
            lrForVarkB.push(s.dominant.vark);
          }
        });

        if (lrForVarkA.length > 0) {
          const {
            table: lrVarkTable,
            aVals: lrVals,
            bVals: domVarkVals,
          } = contingencyTable(lrForVarkA, lrForVarkB);
          const lrVarkChi = chiSquareTest(lrVarkTable);

          output += `1.2 Chi-square (Learning Resource √ó Dominant VARK)\n`;
          output += `    n = ${lrForVarkA.length}\n`;
          output += `    œá¬≤ = ${lrVarkChi.chi2.toFixed(4)}\n`;
          output += `    df = ${lrVarkChi.dof}\n`;
          output += `    p-value = ${lrVarkChi.p.toFixed(4)}\n`;
          output += `    Observation: ${
            lrVarkChi.p < 0.05
              ? "Students‚Äô preferred learning resources and their dominant VARK styles are related in a statistically significant way (p < 0.05)."
              : "No clear statistical link was found between preferred learning resource and dominant VARK style (p ‚â• 0.05)."
          }\n\n`;
        } else {
          output += `1.2 Chi-square (Learning Resource √ó Dominant VARK)\n`;
          output += `    Not enough matched data (missing learning resource or VARK type).\n\n`;
        }

        // 1.3 VARK Scores √ó GPA correlation
        const gpas = students.map((s) => s.meta.gpa).filter((g) => g != null);

        if (gpas.length >= 3) {
          output += `1.3 VARK Styles √ó GPA Correlation Analysis\n`;
          output += "‚îÄ".repeat(50) + "\n\n";

          const varkStyles = [
            { key: "V", label: "Visual" },
            { key: "A", label: "Aural" },
            { key: "R", label: "Read/Write" },
            { key: "K", label: "Kinesthetic" },
          ];

          varkStyles.forEach((style) => {
            const styleScores = students
              .filter((s) => s.meta.gpa != null)
              .map((s) => s.scores.VARK[style.key] || 0);

            const r = pearson(styleScores, gpas);
            const rho = spearman(styleScores, gpas);
            const absR = Math.abs(r);

            let varkNote = "";
            if (absR < 0.2) {
              varkNote = "Negligible or no linear relationship.";
            } else if (r >= 0.2) {
              varkNote = `Positive correlation: Higher ${style.label} scores tend to align with higher GPAs.`;
            } else {
              varkNote = `Negative correlation: Higher ${style.label} scores are associated with lower GPAs in this group.`;
            }

            output += `[${style.label} √ó GPA]:\n`;
            output += `    Pearson r = ${r.toFixed(4)}, Spearman œÅ = ${rho.toFixed(4)}\n`;
            output += `    Analysis Note: ${varkNote}\n\n`;
          });
        } else {
          output += `1.3 VARK Styles √ó GPA Correlation\n`;
          output += `    Not enough data (n < 3 with valid GPA).\n\n`;
        }

        // 2. KOLB MODEL ANALYSES
        output += "„Äê KOLB MODEL ANALYSES „Äë\n";
        output += "‚îÄ".repeat(50) + "\n\n";

        const kolbTypes = [
          "Diverger",
          "Assimilator",
          "Converger",
          "Accommodator",
        ];
        const kolbGroups = kolbTypes.map((type) =>
          students
            .filter((s) => s.dominant.kolb === type && s.meta.gpa != null)
            .map((s) => s.meta.gpa),
        );

        const anovaGpaKolb = oneWayANOVA(kolbGroups);
        if (anovaGpaKolb) {
          output += `2.1 One-way ANOVA (KOLB Type √ó GPA)\n`;
          output += `    F(${anovaGpaKolb.dfBetween}, ${anovaGpaKolb.dfWithin}) = ${anovaGpaKolb.F.toFixed(4)}\n`;
          output += `    p-value = ${anovaGpaKolb.p.toFixed(4)}\n`;
          output += `    Observation: ${
            anovaGpaKolb.p < 0.05
              ? "Mean GPA differs significantly between at least two KOLB types (p < 0.05)."
              : "No statistically significant GPA differences were observed between KOLB types (p ‚â• 0.05)."
          }\n\n`;
          output += `    Group means (GPA):\n`;
          kolbTypes.forEach((type, i) => {
            if (kolbGroups[i].length > 0) {
              output += `    - ${type}: Œº = ${anovaGpaKolb.groupMeans[
                i
              ].toFixed(2)} (n = ${kolbGroups[i].length})\n`;
            }
          });
          output += "\n";
        } else {
          output += `2.1 One-way ANOVA (KOLB Type √ó GPA)\n`;
          output += `    Not enough data (need at least 2 KOLB groups with valid GPA).\n\n`;
        }

        // --- 2. KOLB AXES ANALYSIS ---

        const kolbData = students.filter((s) => s.meta.gpa != null);
        const gpasForKolb = kolbData.map((s) => s.meta.gpa);

        const acMinusCE = kolbData.map(
          (s) => (s.scores.Kolb.AC || 0) - (s.scores.Kolb.CE || 0),
        );
        const aeMinusRO = kolbData.map(
          (s) => (s.scores.Kolb.AE || 0) - (s.scores.Kolb.RO || 0),
        );

        if (gpasForKolb.length >= 3) {
          // 2.2 AC‚ÄìCE Axis Analysis
          const rAcCe = pearson(acMinusCE, gpasForKolb);
          const absRAcCe = Math.abs(rAcCe);
          let interpAcCe =
            absRAcCe < 0.1
              ? "No significant linear association was detected between the observed parameters."
              : `A ${absRAcCe < 0.3 ? "weak" : "moderate"} ${rAcCe > 0 ? "positive" : "negative"} correlation exists. ${
                  rAcCe > 0
                    ? "Abstract learners (AC) tend to have higher GPAs."
                    : "Concrete learners (CE) perform better."
                }`;

          output += `2.2 Correlation (KOLB AC‚ÄìCE Axis √ó GPA)\n`;
          output += `    n = ${gpasForKolb.length} | Pearson r = ${rAcCe.toFixed(4)}\n`;
          output += `    Analysis Note: ${interpAcCe}\n\n`;

          // 2.3 AE‚ÄìRO Axis Analysis
          const rAeRo = pearson(aeMinusRO, gpasForKolb);
          const absRAeRo = Math.abs(rAeRo);
          let interpAeRo =
            absRAeRo < 0.1
              ? "No significant linear association was detected between the observed parameters."
              : `A ${absRAeRo < 0.3 ? "weak" : "moderate"} ${rAeRo > 0 ? "positive" : "negative"} correlation exists. ${
                  rAeRo > 0
                    ? "Active learners (AE) tend to have higher GPAs."
                    : "Reflective learners (RO) perform better."
                }`;

          output += `2.3 Correlation (KOLB AE‚ÄìRO Axis √ó GPA)\n`;
          output += `    n = ${gpasForKolb.length} | Pearson r = ${rAeRo.toFixed(4)}\n`;
          output += `    Analysis Note: ${interpAeRo}\n\n`;
        } else {
          output += `2.2 & 2.3 KOLB Axes Analysis\n`;
          output += `    Not enough data (n < 3).\n\n`;
        }

        // 3. WEEKLY STUDY HOURS ANALYSES
        output += "„Äê WEEKLY STUDY HOURS ANALYSES „Äë\n";
        output += "‚îÄ".repeat(50) + "\n\n";

        // 3.1 Weekly hours √ó GPA
        const whForGpa = [];
        const gpaForWh = [];
        students.forEach((s) => {
          if (s.meta.weeklyHours != null && s.meta.gpa != null) {
            whForGpa.push(s.meta.weeklyHours);
            gpaForWh.push(s.meta.gpa);
          }
        });

        if (whForGpa.length >= 3) {
          const pearsonWh = pearson(whForGpa, gpaForWh);
          const spearmanWh = spearman(whForGpa, gpaForWh);
          const r = pearsonWh;
          const absR = Math.abs(r);

          let strength = "";
          let direction = r > 0 ? "positive" : "negative";

          if (absR < 0.1) strength = "negligible (no relationship)";
          else if (absR < 0.3) strength = "small/weak";
          else if (absR < 0.5) strength = "medium/moderate";
          else strength = "large/strong";

          let interpWh = "";
          if (absR < 0.1) {
            interpWh =
              "There is no discernible linear relationship between study hours and GPA.";
          } else {
            interpWh = `There is a ${strength} ${direction} correlation. ${
              r > 0
                ? "Generally, more study hours align with higher academic performance."
                : "Surprisingly, increased study hours do not correlate with higher GPAs in this sample."
            }`;
          }

          output += `3.1 Correlation (Weekly Study Hours √ó GPA)\n`;
          output += `    n = ${whForGpa.length}\n`;
          output += `    Pearson r = ${r.toFixed(4)}\n`;
          output += `    Spearman œÅ = ${spearmanWh.toFixed(4)}\n`;
          output += `    Analysis Note: ${interpWh}\n`;
          output += `    Observation: Results are descriptive for this sample (n=${whForGpa.length}).\n\n`;
        } else {
          output += `3.1 Correlation (Weekly Study Hours √ó GPA)\n`;
          output += `    Not enough data (n < 3).\n\n`;
        }

        // 3.2 Weekly hours √ó dominant VARK (ANOVA)
        const varkCats = ["V", "A", "R", "K", "Multimodal"];
        const varkHourGroups = varkCats.map((cat) =>
          students
            .filter(
              (s) => s.dominant.vark === cat && s.meta.weeklyHours != null,
            )
            .map((s) => s.meta.weeklyHours),
        );
        const anovaWhVark = oneWayANOVA(varkHourGroups);

        if (anovaWhVark) {
          output += `3.2 One-way ANOVA (Dominant VARK √ó Weekly Study Hours)\n`;
          output += `    F(${anovaWhVark.dfBetween}, ${anovaWhVark.dfWithin}) = ${anovaWhVark.F.toFixed(4)}\n`;
          output += `    p-value = ${anovaWhVark.p.toFixed(4)}\n`;
          output += `    Observation: ${
            anovaWhVark.p < 0.05
              ? "Average weekly study hours differ significantly between at least two VARK groups (p < 0.05)."
              : "No statistically significant differences in weekly study hours were found between VARK groups (p ‚â• 0.05)."
          }\n`;
          output += `    Group means (hours):\n`;
          varkCats.forEach((cat, i) => {
            if (varkHourGroups[i].length > 0) {
              output += `    - ${cat}: Œº = ${anovaWhVark.groupMeans[i].toFixed(
                2,
              )} (n = ${varkHourGroups[i].length})\n`;
            }
          });
          output += "\n";
        } else {
          output += `3.2 One-way ANOVA (Dominant VARK √ó Weekly Study Hours)\n`;
          output += `    Not enough data (need at least 2 VARK groups with weekly hours).\n\n`;
        }

        // 3.3 Weekly hours √ó KOLB type (ANOVA)
        const kolbHourGroups = kolbTypes.map((type) =>
          students
            .filter(
              (s) => s.dominant.kolb === type && s.meta.weeklyHours != null,
            )
            .map((s) => s.meta.weeklyHours),
        );
        const anovaWhKolb = oneWayANOVA(kolbHourGroups);

        if (anovaWhKolb) {
          output += `3.3 One-way ANOVA (KOLB Type √ó Weekly Study Hours)\n`;
          output += `    F(${anovaWhKolb.dfBetween}, ${anovaWhKolb.dfWithin}) = ${anovaWhKolb.F.toFixed(4)}\n`;
          output += `    p-value = ${anovaWhKolb.p.toFixed(4)}\n`;
          output += `    Observation: ${
            anovaWhKolb.p < 0.05
              ? "Average weekly study hours differ significantly between at least two KOLB types (p < 0.05)."
              : "No statistically significant differences in weekly study hours were found between KOLB types (p ‚â• 0.05)."
          }\n`;
          output += `    Group means (hours):\n`;
          kolbTypes.forEach((type, i) => {
            if (kolbHourGroups[i].length > 0) {
              output += `    - ${type}: Œº = ${anovaWhKolb.groupMeans[i].toFixed(
                2,
              )} (n = ${kolbHourGroups[i].length})\n`;
            }
          });
          output += "\n";
        } else {
          output += `3.3 One-way ANOVA (KOLB Type √ó Weekly Study Hours)\n`;
          output += `    Not enough data (need at least 2 KOLB groups with weekly hours).\n\n`;
        }

        // 4. GENDER AND LEARNING STYLE ANALYSES
        output += "„Äê GENDER AND LEARNING STYLE ANALYSES „Äë\n";
        output += "‚îÄ".repeat(50) + "\n\n";

        // 4.1 Gender √ó Dominant VARK (Chi-square)
        const genderForVarkA = [];
        const genderForVarkB = [];
        students.forEach((s) => {
          if (s.meta.gender && s.dominant.vark) {
            genderForVarkA.push(s.meta.gender);
            genderForVarkB.push(s.dominant.vark);
          }
        });

        if (genderForVarkA.length > 0) {
          const {
            table: genderVarkTable,
            aVals: genderVals,
            bVals: genderVarkVals,
          } = contingencyTable(genderForVarkA, genderForVarkB);
          const genderVarkChi = chiSquareTest(genderVarkTable);

          output += `4.1 Chi-square (Gender √ó Dominant VARK)\n`;
          output += `    n = ${genderForVarkA.length}\n`;
          output += `    œá¬≤ = ${genderVarkChi.chi2.toFixed(4)}\n`;
          output += `    df = ${genderVarkChi.dof}\n`;
          output += `    p-value = ${genderVarkChi.p.toFixed(4)}\n`;
          output += `    Observation: ${
            genderVarkChi.p < 0.05
              ? "Learning style preferences (VARK) differ by gender in a statistically significant way (p < 0.05)."
              : "No statistically significant association was found between gender and dominant VARK style (p ‚â• 0.05)."
          }\n\n`;
        } else {
          output += `4.1 Chi-square (Gender √ó Dominant VARK)\n`;
          output += `    Not enough data (gender or VARK type missing).\n\n`;
        }

        // 4.2 Gender √ó KOLB type (Chi-square)
        const genderForKolbA = [];
        const genderForKolbB = [];
        students.forEach((s) => {
          if (s.meta.gender && s.dominant.kolb) {
            genderForKolbA.push(s.meta.gender);
            genderForKolbB.push(s.dominant.kolb);
          }
        });

        if (genderForKolbA.length > 0) {
          const {
            table: genderKolbTable,
            aVals: genderKolbValsA,
            bVals: genderKolbValsB,
          } = contingencyTable(genderForKolbA, genderForKolbB);
          const genderKolbChi = chiSquareTest(genderKolbTable);

          output += `4.2 Chi-square (Gender √ó KOLB Type)\n`;
          output += `    n = ${genderForKolbA.length}\n`;
          output += `    œá¬≤ = ${genderKolbChi.chi2.toFixed(4)}\n`;
          output += `    df = ${genderKolbChi.dof}\n`;
          output += `    p-value = ${genderKolbChi.p.toFixed(4)}\n`;
          output += `    Observation: ${
            genderKolbChi.p < 0.05
              ? "KOLB learning types are distributed differently across genders (p < 0.05)."
              : "No statistically significant association was found between gender and KOLB type (p ‚â• 0.05)."
          }\n\n`;
        } else {
          output += `4.2 Chi-square (Gender √ó KOLB Type)\n`;
          output += `    Not enough data (gender or KOLB type missing).\n\n`;
        }

        // --- 5. STUDENT PROFILING: K-MEANS CLUSTERING ---
        output += "„Äê STUDENT PROFILING: K-MEANS CLUSTERING „Äë\n";
        output += "Method: K-Means (Normalized GPA & Learning Styles)\n";
        output += "‚îÄ".repeat(50) + "\n\n";

        // 5. VARK CLUSTERING ANALYSIS (WITH 1st & 2nd DOMINANTS)
        const varkOrder = ["V", "A", "R", "K", "Multimodal"];
        const clusterSource = students
          .filter(
            (s) =>
              s.meta.gpa != null &&
              s.dominant.vark &&
              varkOrder.includes(s.dominant.vark),
          )
          .map((s) => ({
            gpa: s.meta.gpa,
            vark: s.dominant.vark,
          }));

        if (clusterSource.length >= 4) {
          const gList = clusterSource.map((d) => d.gpa);
          const vNumList = clusterSource.map((d) => varkOrder.indexOf(d.vark));

          const gMean = ss.mean(gList);
          const vMean = ss.mean(vNumList);
          const gStd = ss.standardDeviation(gList) || 1;
          const vStd = ss.standardDeviation(vNumList) || 1;

          const normPoints = clusterSource.map((d, i) => ({
            x: (d.gpa - gMean) / gStd,
            y: (vNumList[i] - vMean) / vStd,
          }));

          const kCount = Math.min(3, normPoints.length);

          const km = kMeans2D(normPoints, kCount);

          if (km) {
            const clusters = Array.from({ length: km.k }, () => ({
              count: 0,
              gpaSum: 0,
              varkCounts: { V: 0, A: 0, R: 0, K: 0, Multimodal: 0 },
            }));

            km.assignments.forEach((cIdx, i) => {
              const c = clusters[cIdx];
              c.count++;
              c.gpaSum += clusterSource[i].gpa;
              const label = clusterSource[i].vark;
              if (label && c.varkCounts[label] !== undefined) {
                c.varkCounts[label]++;
              }
            });

            output += "„Äê MULTIVARIATE CLUSTERING: GPA & VARK MODELS „Äë\n";
            clusters.forEach((c, idx) => {
              if (c.count === 0) return;
              const meanG = c.gpaSum / c.count;

              const sortedStyles = Object.entries(c.varkCounts)
                .filter((entry) => entry[1] > 0)
                .sort((a, b) => b[1] - a[1]);

              const firstStyle = sortedStyles[0] ? sortedStyles[0][0] : "-";
              const secondStyle = sortedStyles[1] ? sortedStyles[1][0] : null;

              let styleOutput = firstStyle;
              if (secondStyle) styleOutput += `, then ${secondStyle}`;

              const details = Object.entries(c.varkCounts)
                .filter((entry) => entry[1] > 0)
                .sort((a, b) => b[1] - a[1])
                .map((entry) => `${entry[0]}: ${entry[1]}`)
                .join(", ");

              output += `Cluster ${idx + 1}: n = ${c.count}, mean GPA ‚âà ${meanG.toFixed(2)}\n`;
              output += `   Distribution: [ ${details} ]\n`;
            });
            output += "\n";
          }
        }

        //  6. KOLB CLUSTERING ANALYSIS (WITH 1st & 2nd DOMINANTS)
        const kolbOrder = [
          "Diverger",
          "Assimilator",
          "Converger",
          "Accommodator",
        ];
        const kolbClusterSource = students
          .filter((s) => s.meta.gpa != null && s.dominant.kolb)
          .map((s) => ({
            gpa: s.meta.gpa,
            kolb: s.dominant.kolb,
          }));

        if (kolbClusterSource.length >= 4) {
          const gListK = kolbClusterSource.map((d) => d.gpa);
          const kNumList = kolbClusterSource.map((d) =>
            kolbOrder.indexOf(d.kolb),
          );

          const gMeanK = ss.mean(gListK);
          const kMeanK = ss.mean(kNumList);
          const gStdK = ss.standardDeviation(gListK) || 1;
          const kStdK = ss.standardDeviation(kNumList) || 1;

          const normPointsK = kolbClusterSource.map((d, i) => ({
            x: (d.gpa - gMeanK) / gStdK,
            y: (kNumList[i] - kMeanK) / kStdK,
          }));

          const kCountK = Math.min(3, normPointsK.length);
          const kmK = kMeans2D(normPointsK, kCountK);

          if (kmK) {
            const kolbClusters = Array.from({ length: kmK.k }, () => ({
              count: 0,
              gpaSum: 0,
              kolbCounts: {
                Diverger: 0,
                Assimilator: 0,
                Converger: 0,
                Accommodator: 0,
              },
            }));

            kmK.assignments.forEach((cIdx, i) => {
              const c = kolbClusters[cIdx];
              c.count++;
              c.gpaSum += kolbClusterSource[i].gpa;
              const label = kolbClusterSource[i].kolb;
              if (label && c.kolbCounts[label] !== undefined) {
                c.kolbCounts[label]++;
              }
            });

            output += "„Äê MULTIVARIATE CLUSTERING: GPA & KOLB MODELS „Äë\n";
            kolbClusters.forEach((c, idx) => {
              if (c.count === 0) return;
              const meanG = c.gpaSum / c.count;

              const sortedK = Object.entries(c.kolbCounts)
                .filter((entry) => entry[1] > 0)
                .sort((a, b) => b[1] - a[1]);

              const firstK = sortedK[0] ? sortedK[0][0] : "-";
              const secondK = sortedK[1] ? sortedK[1][0] : null;

              let kolbOutput = firstK;
              if (secondK) kolbOutput += `, then ${secondK}`;

              const detailsK = Object.entries(c.kolbCounts)
                .filter((entry) => entry[1] > 0)
                .sort((a, b) => b[1] - a[1])
                .map((entry) => `${entry[0]}: ${entry[1]}`)
                .join(", ");

              output += `Cluster ${idx + 1}: n = ${c.count}, mean GPA ‚âà ${meanG.toFixed(2)}\n`;
              output += `   Distribution: [ ${detailsK} ]\n`;
            });
            output += "\n";
          }
        }

        output += "=== END OF REPORT ===\n";

        document.getElementById("statOutput").innerText = output;
        populateAdminVarkDetails(varkChi, varkTable, courseVals, varkVals);
        populateAdminKolbDetails(anovaGpaKolb, kolbGroups, kolbTypes);

        if (showAlert)
          alert(
            "Statistical tests have been completed. Please check Admin ‚Üí All Statistics tab.",
          );
      }

      // Charts rendering
      function renderAllCharts() {
        const vTotals = { V: 0, A: 0, R: 0, K: 0 };
        const kolbTypeCounts = {
          Diverger: 0,
          Assimilator: 0,
          Converger: 0,
          Accommodator: 0,
        };

        students.forEach((s) => {
          if (s.scores && s.scores.VARK)
            Object.keys(vTotals).forEach(
              (k) => (vTotals[k] += s.scores.VARK[k] || 0),
            );
          if (s.dominant.kolb) {
            if (kolbTypeCounts.hasOwnProperty(s.dominant.kolb)) {
              kolbTypeCounts[s.dominant.kolb]++;
            }
          }
        });

        const dominantCounts = { V: 0, A: 0, R: 0, K: 0, Multimodal: 0 };

        students.forEach((s) => {
          if (s.dominant && s.dominant.vark) {
            dominantCounts[s.dominant.vark]++;
          }
        });
        // VARK bar
        const vb = document.getElementById("varkBar").getContext("2d");
        if (charts.varkBar) charts.varkBar.destroy();
        charts.varkBar = new Chart(vb, {
          type: "bar",
          data: {
            labels: [
              "Visual",
              "Aural",
              "Read/Write",
              "Kinesthetic",
              "Multimodal",
            ],
            datasets: [
              {
                label: "Students",
                data: [
                  dominantCounts.V,
                  dominantCounts.A,
                  dominantCounts.R,
                  dominantCounts.K,
                  dominantCounts.Multimodal,
                ],
                backgroundColor: [
                  "#3b82f6",
                  "#ef4444",
                  "#10b981",
                  "#f59e0b",
                  "#a855f7",
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              title: { display: true, text: "VARK Style Distribution" },
            },
          },
        });

        // KOLB bar
        const kb = document.getElementById("kolbBar").getContext("2d");
        if (charts.kolbBar) charts.kolbBar.destroy();
        charts.kolbBar = new Chart(kb, {
          type: "bar",
          data: {
            labels: ["Diverger", "Assimilator", "Converger", "Accommodator"],
            datasets: [
              {
                label: "Students",
                data: [
                  kolbTypeCounts.Diverger,
                  kolbTypeCounts.Assimilator,
                  kolbTypeCounts.Converger,
                  kolbTypeCounts.Accommodator,
                ],
                backgroundColor: [
                  "#8b5cf6",
                  "#06b6d4",
                  "#920303",
                  "#A8547A",
                  "#94a3b8",
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              title: { display: true, text: "KOLB Type Distribution" },
            },
          },
        });
      }

      // Admin modal logic
      document.getElementById("btnAdmin").addEventListener("click", () => {
        document.getElementById("adminModal").classList.remove("hidden");
        document.getElementById("adminModal").classList.add("flex");
      });
      document.getElementById("closeAdmin").addEventListener("click", () => {
        document.getElementById("adminModal").classList.add("hidden");
      });
      document.getElementById("adminCancel").addEventListener("click", () => {
        document.getElementById("adminModal").classList.add("hidden");
      });
      document.getElementById("adminLoginBtn").addEventListener("click", () => {
        const pw = document.getElementById("adminPassword").value;
        if (pw === "12345") {
          document.getElementById("adminModal").classList.add("hidden");
          document.getElementById("adminPanel").classList.remove("hidden");
          activateTab("tab-list");
          populateAdminStudents();
          runStatTests(false);
        } else alert("Hatalƒ± ≈üifre");
      });
      document.getElementById("adminClose").addEventListener("click", () => {
        document.getElementById("adminPanel").classList.add("hidden");
      });
      document.getElementById("adminExport").addEventListener("click", () => {
        const blob = new Blob(
          [
            JSON.stringify(
              { students, rawQuestions, exportedAt: new Date().toISOString() },
              null,
              2,
            ),
          ],
          { type: "application/json" },
        );
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "class_report.json";
        a.click();
        URL.revokeObjectURL(url);
      });

      document
        .getElementById("clearStorageBtn")
        .addEventListener("click", () => {
          if (
            !confirm(
              "Are you sure you want to delete all student data from localStorage? This action cannot be undone.",
            )
          )
            return;
          localStorage.removeItem("students_v1");
          students = [];
          renderStudentsTable();
          populateAdminStudents();
          renderAllCharts();
          computeQuickSummary();
          document.getElementById("statOutput").innerText =
            "All student data has been cleared. No statistics are available.";
          alert("All student data in localStorage has been cleared.");
        });

      document.querySelectorAll(".tabBtn").forEach((btn) => {
        btn.addEventListener("click", () => activateTab(btn.dataset.tab));
      });
      function activateTab(tabId) {
        document
          .querySelectorAll(".tabContent")
          .forEach((s) => s.classList.add("hidden"));
        document.getElementById(tabId).classList.remove("hidden");
      }

      // Admin populators
      function populateAdminStudents() {
        const el = document.getElementById("adminStudents");
        if (!students.length) {
          el.innerHTML = '<div class="muted">No students yet.</div>';
          return;
        }
        let html =
          '<table class="min-w-full text-sm"><thead><tr><th>Name</th><th>GPA</th><th>VARK</th><th>KOLB</th><th>Saved at</th><th>Delete</th></tr></thead><tbody>';
        students.forEach((s) => {
          html += `<tr class="border-t"><td>${s.meta.name}</td><td>${
            s.meta.gpa === null ? "-" : s.meta.gpa.toFixed(2)
          }</td><td>${s.dominant.vark || "-"}</td><td>${
            s.dominant.kolb || "-"
          }</td><td class="tiny">${new Date(
            s.meta.savedAt,
          ).toLocaleString()}</td><td><button onclick="deleteAdminStudent('${s.id}')" class="bg-red-500 text-white px-2 py-1 rounded text-xs">Delete</button></td></tr>`;
        });
        html += "</tbody></table>";
        el.innerHTML = html;
      }

      function deleteAdminStudent(id) {
        students = students.filter((s) => s.id !== id);
        localStorage.setItem("students_v1", JSON.stringify(students));

        populateAdminStudents();
        renderStudentsTable();
        renderAllCharts();
        computeQuickSummary();
        runStatTests(false);
      }

      function populateAdminVarkDetails(chi, table, aVals, bVals) {
        const el = document.getElementById("adminVark");
        if (!students.length) {
          el.innerHTML = '<div class="muted">No students yet.</div>';
          return;
        }
        const fixedOrder = ["V", "A", "R", "K", "Multimodal"];
        const totals = { V: 0, A: 0, R: 0, K: 0 };
        const dom = { V: 0, A: 0, R: 0, K: 0, Multimodal: 0 };
        students.forEach((s) => {
          if (s.scores && s.scores.VARK)
            Object.keys(totals).forEach(
              (k) => (totals[k] += s.scores.VARK[k] || 0),
            );
          if (s.dominant && s.dominant.vark)
            dom[s.dominant.vark] = (dom[s.dominant.vark] || 0) + 1;
        });

        const total = students.length;
        const classified = dom.V + dom.A + dom.R + dom.K + dom.Multimodal;
        const getPercentage = (n) =>
          classified > 0 ? ((n / classified) * 100).toFixed(1) : 0;

        let html = `<div class="card p-3">
                <b>Total VARK Scores (all students)</b><br>
                Visual: ${totals.V}<br>
                Aural: ${totals.A}<br>
                Read/Write: ${totals.R}<br>
                Kinesthetic: ${totals.K}<br>
              </div>`;

        html += `<div class="card p-3">
                <b>Dominant VARK Distribution (students)</b><br>
                 Total Participation: <span class="font-bold"> ${total} </span> students<br>
                V: ${dom.V} (${getPercentage(dom.V)}%) | A: ${dom.A} (${getPercentage(dom.A)}%) | R: ${dom.R} (${getPercentage(dom.R)}%) | K: ${dom.K} (${getPercentage(dom.K)}%) | Multimodal: ${dom.Multimodal} (${getPercentage(dom.Multimodal)}%)
              </div>`;

        html += `<div class="card p-3 col-span-2">
                <b>Chi-square Test (Course Type √ó Dominant VARK)</b><br>
                œá¬≤ = ${chi.chi2.toFixed(4)}, df = ${chi.dof}, p = ${chi.p.toFixed(4)}<br>
                <span class="text-xs ${chi.p < 0.05 ? "text-green-600" : "text-gray-500"}">
                  ${chi.p < 0.05 ? "‚úì Significant association (p < 0.05)" : "No significant association"}
                </span>
              </div>`;

        html +=
          '<div class="card p-3 col-span-2"><b>Contingency Table (Course Type √ó Dominant VARK)</b><br>';
        html +=
          '<table class="min-w-full text-sm mt-2"><thead><tr><th>Course type</th>';
        const activeColumns = fixedOrder.filter((type) => bVals.includes(type));
        activeColumns.forEach((b) => (html += `<th>${b}</th>`));
        html += "</tr></thead><tbody>";
        for (let i = 0; i < aVals.length; i++) {
          html += `<tr class="border-t"><td class="font-medium">${aVals[i]}</td>`;

          activeColumns.forEach((type) => {
            const colIndex = bVals.indexOf(type);
            const value = table[i][colIndex] || 0;
            html += `<td class="text-center">${value}</td>`;
          });

          html += "</tr>";
        }
        html += "</tbody></table></div>";

        el.innerHTML = html;
      }

      function populateAdminKolbDetails(anova, groups, types) {
        const el = document.getElementById("adminKolb");
        if (!students.length) {
          el.innerHTML = '<div class="muted">No students yet.</div>';
          return;
        }

        const typeCounts = {
          Diverger: 0,
          Assimilator: 0,
          Converger: 0,
          Accommodator: 0,
        };

        students.forEach((s) => {
          if (s.dominant.kolb) {
            typeCounts[s.dominant.kolb]++;
          }
        });

        const totalStudents = students.length;
        const classifiedCount =
          typeCounts.Diverger +
          typeCounts.Assimilator +
          typeCounts.Converger +
          typeCounts.Accommodator;

        const undefinedStudentCount = totalStudents - classifiedCount;

        let html = `<div class="card p-3">
    <b>KOLB Analysis Summary</b><br>
    Total Participation: <span class="font-bold"> ${totalStudents} </span> students<br>
     ${undefinedStudentCount > 0 ? `<span class="text-green-600 font-bold">${classifiedCount}</span> students in dominant styles, <span class="text-red-600 font-bold">${undefinedStudentCount}</span> students with undefined profile.` : ""}
   <br>
    Diverger: ${typeCounts.Diverger} (${((typeCounts.Diverger / totalStudents) * 100).toFixed(1)}%)<br>
    Assimilator: ${typeCounts.Assimilator} (${((typeCounts.Assimilator / totalStudents) * 100).toFixed(1)}%)<br>
    Converger: ${typeCounts.Converger} (${((typeCounts.Converger / totalStudents) * 100).toFixed(1)}%)<br>
    Accommodator: ${typeCounts.Accommodator} (${((typeCounts.Accommodator / totalStudents) * 100).toFixed(1)}%)
</div>`;

        if (anova) {
          html += `<div class="card p-3">
                  <b>ANOVA (KOLB Type √ó GPA)</b><br>
                  F(${anova.dfBetween}, ${anova.dfWithin}) = ${anova.F.toFixed(4)}<br>
                  p-value = ${anova.p.toFixed(4)}<br>
                  <span class="text-xs ${anova.p < 0.05 ? "text-green-600" : "text-gray-500"}">
                    ${anova.p < 0.05 ? "‚úì Significant differences between groups (p < 0.05)" : "No statistically significant differences between groups"}
                  </span>
                </div>`;

          html +=
            '<div class="card p-3 col-span-2"><b>Group Means (GPA by KOLB Type)</b><br>';
          html +=
            '<table class="min-w-full text-sm mt-2"><thead><tr><th>KOLB Type</th><th>n</th><th>Mean GPA</th></tr></thead><tbody>';
          types.forEach((type, i) => {
            if (groups[i].length > 0) {
              html += `<tr class="border-t"><td>${type}</td><td class="text-center">${
                groups[i].length
              }</td><td class="text-center">${anova.groupMeans[i].toFixed(2)}</td></tr>`;
            }
          });
          html += "</tbody></table></div>";
        } else {
          html += `<div class="card p-3"><b>ANOVA</b><br>Not enough data (less than 2 groups with valid GPA).</div>`;
        }

        el.innerHTML = html;
      }

      //  Import JSON

      document.getElementById("importJSON").addEventListener("change", (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = function (e) {
          const fileContent = e.target.result;
          try {
            const jsonObject = JSON.parse(fileContent);
            const students = jsonObject?.students;
            if (!students) return;

            const lsOldStudents = JSON.parse(
              localStorage.getItem("students_v1") ?? "[]",
            );
            localStorage.setItem(
              "students_v1",
              JSON.stringify([...lsOldStudents, ...students]),
            );
          } catch (error) {
            console.error("Error parsing JSON file:", error);
          }
        };
        reader.readAsText(file);
        window.location.reload();
      });

      // Export CSV / JSON
      document.getElementById("exportCSV").addEventListener("click", () => {
        if (!students.length) {
          alert(
            "No students. Please add at least one student before exporting CSV.",
          );
          return;
        }
        const header = [
          "name",
          "gpa",
          "gender",
          "courseType",
          "weeklyHours",
          "learningResource",
          "varkV",
          "varkA",
          "varkR",
          "varkK",
          "varkDominant",
          "kolbCE",
          "kolbRO",
          "kolbAC",
          "kolbAE",
          "kolbType",
          "savedAt",
        ];
        const rows = students.map((s) => [
          s.meta.name,
          s.meta.gpa === null ? "" : s.meta.gpa,
          s.meta.gender || "",
          s.meta.courseType || "",
          s.meta.weeklyHours || "",
          s.meta.learningResource || "",
          s.scores.VARK.V,
          s.scores.VARK.A,
          s.scores.VARK.R,
          s.scores.VARK.K,
          s.dominant.vark || "",
          s.scores.Kolb.CE,
          s.scores.Kolb.RO,
          s.scores.Kolb.AC,
          s.scores.Kolb.AE,
          s.dominant.kolb || "",
          s.meta.savedAt,
        ]);
        let csv =
          header.join(",") +
          "\n" +
          rows
            .map((r) => r.map((v) => `"${String(v || "")}"`).join(","))
            .join("\n");
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "students.csv";
        a.click();
        URL.revokeObjectURL(url);
      });

      document.getElementById("exportAll").addEventListener("click", () => {
        const payload = {
          students,
          questions: rawQuestions,
          exportedAt: new Date().toISOString(),
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "report.json";
        a.click();
        URL.revokeObjectURL(url);
      });

      function init() {
        renderQuestions();
        renderStudentsTable();
        renderAllCharts();
        computeQuickSummary();
      }
      init();
    </script>
  </body>
</html>
